<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>BALSABOOM - Mejorado</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background: #000; color: white; }
        canvas { image-rendering: pixelated; }
        
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255,0,0,0.4) 100%);
            pointer-events: none; display: none; z-index: 55;
        }

        #instructions {
            position: absolute; width: 100%; height: 100%; 
            background: radial-gradient(circle, #1a2a44 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 100; cursor: pointer; text-align: center;
            border: 10px double #0f0; box-sizing: border-box;
        }
        .ascii-banner { font-size: 8px; line-height: 8px; color: #0f0; margin-bottom: 20px; white-space: pre; }
        #instructions h1 { font-size: 50px; color: #0f0; text-shadow: 5px 5px #f00; margin: 0; animation: title-glow 1.5s infinite alternate; }
        @keyframes title-glow { from { transform: scale(1); } to { transform: scale(1.05); } }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 30px; background: rgba(0,0,0,0.7); padding: 20px; border: 1px solid #0f0; }
        .key { color: #ffff00; font-weight: bold; }

        #ui { position: absolute; top: 20px; left: 20px; z-index: 50; pointer-events: none; }
        .stat-bar { background: #333; width: 200px; height: 20px; border: 2px solid #fff; margin-bottom: 5px; position: relative; }
        #hp-fill { background: #f00; width: 100%; height: 100%; transition: width 0.1s; }
        #shield-tag { color: #00ffff; font-weight: bold; display: none; text-shadow: 0 0 5px #00ffff; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 14px; height: 14px; border: 2px solid #0f0; z-index: 40; transform: translate(-50%, -50%); border-radius: 50%; }

        #chest-prompt { 
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); 
            font-size: 20px; color: #ffff00; display: none; text-shadow: 2px 2px #000; z-index: 45;
        }

        #death-screen {
            position: absolute; width: 100%; height: 100%; 
            background: linear-gradient(rgba(0,0,0,0.9), rgba(50,0,0,0.9)), url('https://www.transparenttextures.com/patterns/carbon-fibre.png');
            display: none; flex-direction: column; justify-content: center;
            align-items: center; z-index: 200; box-sizing: border-box;
            animation: bg-panic 4s infinite;
        }
        .glitch-title { font-size: 80px; color: #f00; font-weight: 900; text-shadow: 3px 3px #fff; animation: glitch 0.3s infinite; margin: 0; }
        .score-box { background: rgba(255, 0, 0, 0.1); border: 2px solid #f00; padding: 20px 50px; margin: 20px; box-shadow: 0 0 20px #f00; transform: skewX(-10deg); }
        #final-score { font-size: 35px; color: #fff; text-transform: uppercase; letter-spacing: 5px; }
        .btn-retry { background: #f00; color: #fff; border: none; padding: 20px 60px; font-size: 30px; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); transition: all 0.2s; }
        .btn-retry:hover { background: #fff; color: #f00; transform: scale(1.1); }
        @keyframes glitch { 0% { transform: translate(2px, 2px); } 50% { transform: translate(-2px, 2px); } 100% { transform: translate(0); } }
        #minimap {
    position: absolute; bottom: 20px; right: 20px;
    width: 150px; height: 150px;
    background: rgba(0, 20, 40, 0.7);
    border: 2px solid #00ffff; border-radius: 50%;
    overflow: hidden; z-index: 60;
}
.dot {
    position: absolute; width: 4px; height: 4px;
    border-radius: 50%; transform: translate(-50%, -50%);
}
#player-dot { background: #fff; width: 6px; height: 6px; z-index: 2; }
    </style>
</head>
<body>
    <div id="minimap"><div id="player-dot" style="left:50%; top:50%"></div></div>

    <div id="damage-overlay"></div>
    <div id="chest-prompt">PULSA <span class="key">E</span> PARA RECUPERAR VIDA (USA 1 PEZ)</div>
    
    <div id="ui">
        <div class="stat-bar"><div id="hp-fill"></div></div>
        <div id="shield-tag">üõ°Ô∏è BARRERA ACTIVA: <span id="shield-count">0</span></div>
        <div style="font-size: 18px;">üß¥ BOTELLAS: <span id="ammo">4</span></div>
        <div style="font-size: 18px;">üê° GLOBOS: <span id="puffers">0</span></div>
        <div id="log" style="color: #0f0; height: 20px; font-weight: bold;"></div>
    </div>

    <div id="instructions">
        <div class="ascii-banner">
  ____          _        _____  ____  ____  __  __ 
 |  _ \   /\   | |      / ____|/ __ \ / __ \|  \/  |
 | |_) | /  \  | |     | (___ | |  | | |  | | \  / |
 |  _ < / /\ \ | |      \___ \| |  | | |  | | |\/| |
 | |_) / ____ \| |____  ____) | |__| | |__| | |  | |
 |____/_/    \_\______||_____/ \____/ \____/|_|  |_|
        </div>
        <h1>BALSABOOM</h1>
        <div class="controls-grid">
            <div><span class="key">WASD</span> CAMINAR</div>
            <div><span class="key">FLECHAS</span> NAVEGAR BALSA</div>
            <div><span class="key">E</span> USAR COFRE (CURAR)</div>
            <div><span class="key">F</span> PESCAR</div>
            <div><span class="key">CLICK IZQ</span> GOLPEAR / DER: LANZAR</div>
            <div><span class="key">Q</span> PEZ GLOBO (¬°BOOM!)</div>
        </div>
        <div class="start-prompt" style="margin-top: 20px; font-size: 24px; animation: blink 0.8s infinite;">PULSA PARA EMPEZAR</div>
    </div>

    <div id="death-screen">
        <h1 class="glitch-title">MORIDO</h1>
        <div class="score-box"><p id="final-score"></p></div>
        <button class="btn-retry" onclick="location.reload()">REINTENTAR</button>
    </div>

    <div id="crosshair"></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
// --- SISTEMA DE AUDIO ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, type, duration, vol = 0.1) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type; 
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + duration);
}
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth * 0.5, window.innerHeight * 0.5, false);
        renderer.domElement.style.width = '100vw'; renderer.domElement.style.height = '100vh';
        document.body.appendChild(renderer.domElement);

        scene.background = new THREE.Color(0x02050a);
        scene.fog = new THREE.FogExp2(0x02050a, 0.025);
        const light = new THREE.AmbientLight(0xffffff, 0.6); scene.add(light);
        const sun = new THREE.PointLight(0x00ffff, 2, 50); scene.add(sun);

        const waterColorNormal = 0x1565c0;
        const waterColorBoss = 0xff1493;
        const waterMat = new THREE.MeshPhongMaterial({ color: waterColorNormal, shininess: 100 });
        const water = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), waterMat);
        water.rotation.x = -Math.PI/2; scene.add(water);

        const raftGroup = new THREE.Group(); scene.add(raftGroup);
        const raft = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0x4e342e }));
        raftGroup.add(raft);

        const chest = new THREE.Group();
        const baseCofre = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.8), new THREE.MeshPhongMaterial({ color: 0x5d4037 }));
        const tapaCofre = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.8), new THREE.MeshPhongMaterial({ color: 0x795548 }));
        tapaCofre.position.y = 0.45;
        const cerradura = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.1), new THREE.MeshPhongMaterial({ color: 0xffd700 }));
        cerradura.position.set(0, 0.3, 0.4);
        chest.add(baseCofre, tapaCofre, cerradura);
        chest.position.set(0, 0.6, 2.2);
        raftGroup.add(chest);

        const bubbleShield = new THREE.Mesh(
            new THREE.SphereGeometry(3.5, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0 })
        );
        raftGroup.add(bubbleShield);

        const yaw = new THREE.Object3D(); const pitch = new THREE.Object3D();
        scene.add(yaw); yaw.add(pitch); pitch.add(camera);
        yaw.position.y = 1.6;

        const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.03, 2), new THREE.MeshPhongMaterial({ color: 0x111 }));
        rod.position.set(0.5, -0.5, -0.8); rod.rotation.x = -Math.PI/3; camera.add(rod);

        let health = 100, ammo = 4, puffers = 0, shield = 0, isDead = false, isFishing = false;
        // --- NUEVAS VARIABLES PARA EL PUNTO 3 ---
let wave = 1;
let enemiesToSpawn = 5;
let isRestPhase = false;
const minimapScale = 1.5; // Zoom del minimapa
        let killCount = 0, bossActive = false, bossHP = 100, bossObj = null;
        let keys = {}, enemies = [], projectiles = [], particles = [], enemyProjectiles = [];
        let velY = 0, canJump = true, mouseLocked = false, startTime = Date.now();
        
        let secretInput = "";
        const secretCode = "casango";

        // VARIABLES NUEVAS PARA MEJORAS
        let shakeAmount = 0;
        let trails = [];

        const updateUI = () => {
            document.getElementById('hp-fill').style.width = Math.max(0, health) + "%";
            document.getElementById('ammo').innerText = ammo;
            document.getElementById('puffers').innerText = puffers;
            document.getElementById('shield-tag').style.display = shield > 0 ? 'block' : 'none';
            document.getElementById('shield-count').innerText = shield;
            bubbleShield.material.opacity = shield > 0 ? 0.3 : 0;
            
            if (killCount >= 40 && !bossActive) triggerBoss();
        
            // A√±adir al final de updateUI()
if (!isRestPhase && !bossActive && enemiesToSpawn === 0 && enemies.length === 0) {
    startRestPhase();
}
        };

        const msg = (t) => { document.getElementById('log').innerText = t; setTimeout(()=>document.getElementById('log').innerText="", 1500); };

        // MEJORA: Sacudida de c√°mara
        function triggerShake(amount) {
            shakeAmount = amount;
        }

        // MEJORA: Estela de la balsa
        function createTrail() {
            const tGeom = new THREE.PlaneGeometry(0.8, 0.8);
            const tMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            const t = new THREE.Mesh(tGeom, tMat);
            t.rotation.x = -Math.PI / 2;
            t.position.copy(raftGroup.position);
            t.position.y = -0.2; // Justo en la superficie
            t.userData = { life: 40 };
            scene.add(t);
            trails.push(t);
        }

        function explosionEfecto(pos, color, radius) {
            triggerShake(0.2); // Sacudida al explotar
            const flash = new THREE.PointLight(color, 15, radius * 2);
            flash.position.copy(pos); scene.add(flash);
            setTimeout(() => scene.remove(flash), 150);
            for(let i=0; i<15; i++) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: color }));
                p.position.copy(pos);
                p.userData.v = new THREE.Vector3((Math.random()-0.5), Math.random(), (Math.random()-0.5));
                p.userData.life = 30; scene.add(p); particles.push(p);
            }
        }

        function triggerBoss() {
            bossActive = true;
            msg("¬°EL MAR SE TI√ëE DE ROSA! LLEGA EL TRIT√ìN...");
            waterMat.color.set(waterColorBoss);
            
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(2, 5), new THREE.MeshPhongMaterial({color: 0x00ffaa}));
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshPhongMaterial({color: 0x00ffaa}));
            head.position.y = 3.5;
            g.add(body, head);
            
            const angle = Math.random() * Math.PI * 2;
            g.position.set(raftGroup.position.x + Math.cos(angle)*35, 2, raftGroup.position.z + Math.sin(angle)*35);
            scene.add(g);
            bossObj = g;
            bossHP = 100;
        }

        function bossShoot() {
            if(!bossActive || isDead) return;
            const p = new THREE.Mesh(new THREE.IcosahedronGeometry(0.8), new THREE.MeshBasicMaterial({color: 0xff00ff}));
            p.position.copy(bossObj.position);
            const dir = new THREE.Vector3().subVectors(yaw.position, bossObj.position).normalize();
            p.userData = { v: dir.multiplyScalar(0.4), life: 250 };
            scene.add(p);
            enemyProjectiles.push(p);
        }

        function pescar() {
            if(isFishing || isDead) return;
            isFishing = true ;
            playSound(600, 'sine', 0.1);
            rod.rotation.x = -Math.PI/1.1;
            msg("LANZANDO ANZUELO...");
            setTimeout(() => {
                const rng = Math.random();
                if(rng > 0.4) {
                    if(rng > 0.85) { shield = 5; msg("¬°BARRERA DE BURBUJAS!");playSound(800, 'sine', 0.2); }
                    else if(rng > 0.7) { puffers++; msg("¬°CAPTURASTE PEZ GLOBO!"); }
                    else { ammo += 5; msg("¬°MUNICI√ìN EXTRA!"); }
                    updateUI();
                } else { msg("NADA POR AQU√ç..."); }
                rod.rotation.x = -Math.PI/3; isFishing = false;
            }, 1000);
        }

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            secretInput += e.key.toLowerCase();
            if (secretInput.length > secretCode.length) secretInput = secretInput.slice(-secretCode.length);
            if (secretInput === secretCode) {
                msg("¬°MODO MAESTRO!");
                ammo += 99; puffers += 10; shield = 10;
                updateUI();
                secretInput = "";
            }
            if(e.code === 'KeyF') pescar();
            if(e.code === 'KeyQ' && puffers > 0) { puffers--; updateUI(); createProjectile(0xffff00, 12, 0.5); }
            if(e.code === 'Space' && canJump) { velY = 0.22; canJump = false; }
            if(e.code === 'KeyE' && !isDead) {
                const distAlCofre = yaw.position.distanceTo(chest.getWorldPosition(new THREE.Vector3()));
                if(distAlCofre < 2.5 && puffers > 0 && health < 100) {
                    puffers--;
                    health = Math.min(100, health + 25);
                    msg("¬°VIDA RESTAURADA!");
                    updateUI();
                }
            }if(e.code === 'KeyE' && !isDead) {
                // C√°lculo de distancia arreglado para balsa m√≥vil
                const dx = (yaw.position.x - raftGroup.position.x);
                const dz = (yaw.position.z - raftGroup.position.z) - 2.2;
                const distAlCofre = Math.sqrt(dx*dx + dz*dz);

                if(distAlCofre < 2.0) { 
                    if(puffers > 0 && health < 100) {
                        puffers--;
                        health = Math.min(100, health + 25);
                        if(typeof playSound === 'function') playSound(500, 'sine', 0.2);
                        msg("¬°VIDA RESTAURADA!");
                        updateUI();
                    } else if (health >= 100) {
                        msg("VIDA AL M√ÅXIMO");
                    } else {
                        msg("USA 1 PEZ GLOBO PARA CURAR");
                    }
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);
        
        document.addEventListener('mousedown', e => {
            if(!mouseLocked || isDead) return;
            if(e.button === 0) {
                playSound(150, 'sine', 0.1);
                rod.rotation.x = -Math.PI/6;
                const ray = new THREE.Raycaster(); ray.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = ray.intersectObjects(enemies);
                if(hits.length > 0 && hits[0].distance < 5) {
                    scene.remove(hits[0].object); enemies = enemies.filter(en => en !== hits[0].object);
                    killCount++; updateUI();
                    explosionEfecto(hits[0].point, 0xff00ff, 2);
                }
                setTimeout(()=>rod.rotation.x = -Math.PI/3, 100);
            }
            if(e.button === 2 && ammo > 0) {
                playSound(400, 'triangle', 0.2);
                ammo--; updateUI(); createProjectile(0x00ffff, 5, 1.0); }
        });

        // MEJORA: Iluminaci√≥n din√°mica en proyectiles
        function createProjectile(color, rad, speed) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({ color: color }));
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            p.position.copy(camera.getWorldPosition(new THREE.Vector3()));
            
            // A√±adir luz al proyectil
            const pLight = new THREE.PointLight(color, 8, 10);
            p.add(pLight);

            p.userData = { v: dir.multiplyScalar(speed), rad: rad, life: 80, isPuffer: (color === 0xffff00) };
            scene.add(p); projectiles.push(p);
        }

        document.getElementById('instructions').addEventListener('click', () => document.body.requestPointerLock());
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === document.body;
            document.getElementById('instructions').style.display = mouseLocked ? 'none' : 'flex';
        });
        document.addEventListener('mousemove', e => {
            if(!mouseLocked || isDead) return;
            yaw.rotation.y -= e.movementX * 0.003;
            pitch.rotation.x -= e.movementY * 0.003;
            pitch.rotation.x = THREE.MathUtils.clamp(pitch.rotation.x, -1.4, 1.4);
        });

        function spawnEnemy() {
    if(isDead || bossActive || isRestPhase) return;

    if(enemiesToSpawn > 0) {
        const s = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1.2), new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0x220022 }));
        const angle = Math.random() * Math.PI * 2;
        // Aparecen alrededor de la balsa
        s.position.set(raftGroup.position.x + Math.cos(angle)*40, -0.5, raftGroup.position.z + Math.sin(angle)*40);
        scene.add(s); 
        enemies.push(s);
        enemiesToSpawn--;
        
        // Velocidad de aparici√≥n seg√∫n la oleada
        setTimeout(spawnEnemy, Math.max(500, 2000 - (wave * 100)));
    } else if (enemies.length === 0) {
        // Si no quedan enemigos por crear y no hay ninguno vivo, descanso
        startRestPhase();
    }
}

function startRestPhase() {
    if(isRestPhase) return;
    isRestPhase = true;
    msg(`¬°OLEADA ${wave} COMPLETADA! PESCA LIBRE (15s)`);
    if(typeof playSound === 'function') playSound(300, 'sine', 0.5); 
    
    setTimeout(() => {
        wave++;
        enemiesToSpawn = 5 + (wave * 3); 
        isRestPhase = false;
        msg(`¬°ATENCI√ìN! OLEADA ${wave}`);
        spawnEnemy(); // Llama a spawn de nuevo
    }, 15000); 
}

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const wave = Math.sin(time) * 0.15;
            raftGroup.position.y = wave;
            sun.position.set(raftGroup.position.x, 5, raftGroup.position.z);

            // Aplicar sacudida a la c√°mara
            if (shakeAmount > 0) {
                camera.position.x = (Math.random() - 0.5) * shakeAmount;
                camera.position.y = (Math.random() - 0.5) * shakeAmount;
                shakeAmount *= 0.9; // Atenuaci√≥n
            } else {
                camera.position.set(0, 0, 0);
            }

            if(isDead) return;
            const gameTime = (Date.now() - startTime) / 1000;

            if(mouseLocked) {
                const balsaVel = 0.15;
                let balsaMovida = false;
                if(keys['ArrowUp']) {
                    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(raftGroup.quaternion);
                    raftGroup.position.addScaledVector(dir, balsaVel);
                    balsaMovida = true;
                }
                if(keys['ArrowDown']) {
                    const dir = new THREE.Vector3(0,0,1).applyQuaternion(raftGroup.quaternion);
                    raftGroup.position.addScaledVector(dir, balsaVel);
                    balsaMovida = true;
                }
                if(keys['ArrowLeft']) raftGroup.rotation.y += 0.04;
                if(keys['ArrowRight']) raftGroup.rotation.y -= 0.04;

                // Generar estela si se mueve
                if(balsaMovida && Math.random() > 0.7) createTrail();

                // MOVIMIENTO DEL PERSONAJE (WASD)
                const pD = new THREE.Vector3();
                if(keys['KeyW']) pD.z -= 1; if(keys['KeyS']) pD.z += 1;
                if(keys['KeyA']) pD.x -= 1; if(keys['KeyD']) pD.x += 1;
                if(pD.length() > 0) {
                    pD.applyQuaternion(yaw.quaternion).normalize();
                    yaw.position.addScaledVector(pD, 0.12);
                }
                yaw.position.y += velY;
                const ground = 1.6 + wave;
                if(yaw.position.y > ground) velY -= 0.01; else { yaw.position.y = ground; velY = 0; canJump = true; }
            }

            // Actualizar estelas
            trails.forEach((t, i) => {
                t.userData.life--;
                t.scale.multiplyScalar(1.03); // Se expande
                t.material.opacity -= 0.015;
                if (t.userData.life <= 0) {
                    scene.remove(t);
                    trails.splice(i, 1);
                }
            });

            yaw.position.x = THREE.MathUtils.clamp(yaw.position.x, raftGroup.position.x-2.7, raftGroup.position.x+2.7);
            yaw.position.z = THREE.MathUtils.clamp(yaw.position.z, raftGroup.position.z-2.7, raftGroup.position.z+2.7);

            enemies.forEach((s, idx) => {
                const dir = new THREE.Vector3().subVectors(yaw.position, s.position).normalize();
                s.position.addScaledVector(dir, 0.06 + (gameTime * 0.001));
                s.position.y = -0.5 + wave;
                if(s.position.distanceTo(yaw.position) < 2.2) {
                    if(shield > 0) {
                        shield -= 0.1;
                        if(shield < 0) shield = 0;
                    } else {
                        health -= 0.8;
                        playSound(80, 'sawtooth', 0.1, 0.05);
                        triggerShake(0.1); // Sacudida por da√±o constante
                    }
                    document.getElementById('damage-overlay').style.display = 'block';
                    setTimeout(()=>document.getElementById('damage-overlay').style.display = 'none', 30);
                    updateUI();
                }
            });

            enemyProjectiles.forEach((ep, i) => {
                ep.position.add(ep.userData.v); ep.userData.life--;
                if(ep.position.distanceTo(yaw.position) < 2) {
                    if(shield > 0) {
                        shield -= 1;
                        if(shield < 0) shield = 0;
                        msg("¬°ESCUDO ABSORBI√ì IMPACTO!");
                    } else {
                        health -= 15;
                        triggerShake(0.4); // Sacudida fuerte por impacto
                    }
                    updateUI();
                    scene.remove(ep); enemyProjectiles.splice(i,1);
                }
                if(ep.userData.life <= 0) { scene.remove(ep); enemyProjectiles.splice(i,1); }
            });

            projectiles.forEach((p, i) => {
                p.position.add(p.userData.v); p.userData.life--;
                
                if(bossActive && p.position.distanceTo(bossObj.position) < 4) {
                    const dmg = p.userData.isPuffer ? 15 : 5;
                    bossHP -= dmg;
                    explosionEfecto(p.position, 0xffffff, 2);
                    scene.remove(p); projectiles.splice(i, 1);
                    if(bossHP <= 0) {
                        explosionEfecto(bossObj.position, 0x00ffaa, 10);
                        scene.remove(bossObj);
                        bossActive = false;
                        killCount = 0;
                        puffers += 20;
                        waterMat.color.set(waterColorNormal);
                        msg("¬°TRIT√ìN DERROTADO! +20 PECES GLOBO");
                        updateUI();
                        setTimeout(spawnEnemy, 3000);
                    }
                    return;
                }

                let collision = false;
                enemies.forEach((en, ei) => { 
                    if(en.position.distanceTo(p.position) < 1.5) {
                        scene.remove(en); enemies.splice(ei, 1);
                        killCount++; updateUI();
                        collision = true;
                    }
                });

                if(p.userData.life <= 0 || collision) {
                    explosionEfecto(p.position, p.userData.isPuffer ? 0xffff00 : 0x00ffff, p.userData.rad);
                    scene.remove(p); projectiles.splice(i, 1);
                }
            });

            particles.forEach((p, i) => {
                p.position.add(p.userData.v); p.userData.life--;
                if(p.userData.life <= 0) { scene.remove(p); particles.splice(i,1); }
            });

            if(health <= 0) {
                isDead = true; document.exitPointerLock();
                document.getElementById('death-screen').style.display = 'flex';
                document.getElementById('final-score').innerText = `TIEMPO: ${Math.floor(gameTime)} SEG`;
            }
            // --- L√ìGICA DEL MINIMAPA ---
const minimap = document.getElementById('minimap');
if (minimap) {
    // Eliminar puntos rojos anteriores para refrescar
    document.querySelectorAll('.enemy-dot').forEach(d => d.remove());
    
    enemies.forEach(en => {
        // Calcular posici√≥n relativa del enemigo respecto a la balsa
        const dx = (en.position.x - raftGroup.position.x) * minimapScale;
        const dz = (en.position.z - raftGroup.position.z) * minimapScale;
        
        // Solo dibujar si est√° dentro del c√≠rculo del mapa (radio 75px)
        if (Math.sqrt(dx*dx + dz*dz) < 70) {
            const dot = document.createElement('div');
            dot.className = 'dot enemy-dot';
            dot.style.position = 'absolute';
            dot.style.width = '4px';
            dot.style.height = '4px';
            dot.style.background = '#ff00ff';
            dot.style.borderRadius = '50%';
            dot.style.left = (75 + dx) + 'px';
            dot.style.top = (75 + dz) + 'px';
            minimap.appendChild(dot);
        }
    });
}
// --- CONTROL DEL MENSAJE DEL COFRE ---
            const dX = (yaw.position.x - raftGroup.position.x);
            const dZ = (yaw.position.z - raftGroup.position.z) - 2.2;
            const distCofre = Math.sqrt(dX*dX + dZ*dZ);
            const prompt = document.getElementById('chest-prompt');
            if(prompt) prompt.style.display = (distCofre < 2.0) ? 'block' : 'none';
            renderer.render(scene, camera);
        }

        setInterval(() => { if(bossActive) bossShoot(); }, 2000);

        spawnEnemy(); animate();
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>